/**
 * @file RS03Motor.h
 * @brief Header file for RS03 motor control library
 * @author Generated by AI Assistant
 * @date 2023
 */

#ifndef RS03MOTOR_H
#define RS03MOTOR_H

#include <Arduino.h>
#include <Adafruit_MCP2515.h>

// Constants for value mapping
#define P_MIN -12.57f
#define P_MAX 12.57f 
#define V_MIN -20.0f
#define V_MAX 20.0f
#define KP_MIN 0.0f
#define KP_MAX 5000.0f
#define KD_MIN 0.0f
#define KD_MAX 100.0f
#define T_MIN -60.0f
#define T_MAX 60.0f

// Motor operating modes
#define MODE_OPERATION 0    // Operation Mode
#define MODE_POSITION_PP 1  // Position Mode (PP)
#define MODE_VELOCITY 2     // Velocity Mode
#define MODE_CURRENT 3      // Current Mode
#define MODE_POSITION_CSP 5 // Position Mode (CSP)

// Parameter indices
#define PARAM_RUN_MODE 0x7005
#define PARAM_IQ_REF 0x7006
#define PARAM_SPD_REF 0x700A
#define PARAM_LIMIT_TORQUE 0x700B
#define PARAM_CUR_KP 0x7010
#define PARAM_CUR_KI 0x7011
#define PARAM_CUR_FILT_GAIN 0x7014
#define PARAM_LOC_REF 0x7016
#define PARAM_LIMIT_SPD 0x7017
#define PARAM_LIMIT_CUR 0x7018
#define PARAM_MECH_POS 0x7019
#define PARAM_IQF 0x701A
#define PARAM_MECH_VEL 0x701B
#define PARAM_VBUS 0x701C
#define PARAM_LOC_KP 0x701E
#define PARAM_SPD_KP 0x701F
#define PARAM_SPD_KI 0x7020
#define PARAM_SPD_FILT_GAIN 0x7021
#define PARAM_ACC_RAD 0x7022
#define PARAM_VEL_MAX 0x7024
#define PARAM_ACC_SET 0x7025
#define PARAM_EPS_CAN_TIME 0x7026
#define PARAM_CAN_TIMEOUT 0x7028
#define PARAM_ZERO_STA 0x7029

// Communication types
#define COMM_GET_DEVICE_ID 0x0
#define COMM_OPERATION_CONTROL 0x1
#define COMM_MOTOR_FEEDBACK 0x2
#define COMM_MOTOR_ENABLE 0x3
#define COMM_MOTOR_STOP 0x4
#define COMM_SET_ZERO 0x6
#define COMM_SET_CAN_ID 0x7
#define COMM_READ_PARAM 0x11
#define COMM_WRITE_PARAM 0x12
#define COMM_FAULT_FEEDBACK 0x15
#define COMM_SAVE_PARAMS 0x16
#define COMM_SET_BAUDRATE 0x17
#define COMM_ACTIVE_REPORTING 0x18

// CAN frame structure
struct can_frame {
    uint32_t can_id;  // 32 bit CAN_ID
    uint8_t can_dlc;  // frame payload length in byte
    uint8_t data[8];  // payload
};

/**
 * @brief Struct to hold motor feedback data
 */
typedef struct {
    float position;     // Current angle in radians
    float velocity;     // Current angular velocity in rad/s
    float torque;       // Current torque in Nm
    float temperature;  // Current temperature in Celsius
    uint8_t fault;      // Fault flags
    uint8_t mode;       // Current operation mode
} RS03MotorFeedback;

/**
 * @brief Struct to hold motor fault information
 */
typedef struct {
    bool uncalibrated;      // Motor not calibrated
    bool overload;          // Gridlock overload fault
    bool encoder_fault;     // Magnetic coding fault
    bool overtemperature;   // Overtemperature fault
    bool overcurrent;       // Overcurrent fault
    bool undervoltage;      // Undervoltage fault
    uint32_t fault_details; // Detailed fault information
    char fault_str[256];    // Human readable fault description
} RS03MotorFault;

/**
 * @brief Class for controlling RS03 motors via CAN bus
 */
class RS03Motor {
public:
    /**
     * @brief Constructor
     * @param mcp2515_instance Reference to Adafruit_MCP2515 instance
     * @param motor_id Motor CAN ID
     * @param master_id Master device CAN ID
     */
    RS03Motor(Adafruit_MCP2515 &mcp2515_instance, uint8_t motor_id = 1, uint8_t master_id = 0);

    /**
     * @brief Initialize the motor
     * @return True if initialization successful
     */
    bool begin();

    /**
     * @brief Enable the motor
     * @return True if command sent successfully
     */
    bool enable();

    /**
     * @brief Disable the motor
     * @param clear_fault Whether to clear fault (1) or not (0)
     * @return True if command sent successfully
     */
    bool disable(bool clear_fault = false);

    /**
     * @brief Set motor operation mode
     * @param mode Operation mode (0=Operation, 1=Position PP, 2=Velocity, 3=Current, 5=Position CSP)
     * @return True if command sent successfully
     */
    bool setMode(uint8_t mode);

    /**
     * @brief Set position (CSP mode)
     * @param position Target position in radians
     * @return True if command sent successfully
     */
    bool setPosition(float position);

    /**
     * @brief Set position with parameters (PP mode)
     * @param position Target position in radians
     * @param velocity Maximum velocity in rad/s
     * @param acceleration Maximum acceleration in rad/s^2
     * @return True if command sent successfully
     */
    bool setPositionWithParams(float position, float velocity, float acceleration);

    /**
     * @brief Set velocity
     * @param velocity Target velocity in rad/s
     * @return True if command sent successfully
     */
    bool setVelocity(float velocity);

    /**
     * @brief Set acceleration for velocity mode
     * @param acceleration Acceleration in rad/s^2
     * @return True if command sent successfully
     */
    bool setAcceleration(float acceleration);

    /**
     * @brief Set current (torque)
     * @param current Target current in amps
     * @return True if command sent successfully
     */
    bool setCurrent(float current);

    /**
     * @brief Set operation control parameters
     * @param position Target position in radians
     * @param velocity Target velocity in rad/s
     * @param torque Target torque in Nm
     * @param kp Position gain
     * @param kd Velocity gain
     * @return True if command sent successfully
     */
    bool setOperationControl(float position, float velocity, float torque, float kp, float kd);

    /**
     * @brief Set torque limit
     * @param torque_limit Torque limit in Nm
     * @return True if command sent successfully
     */
    bool setTorqueLimit(float torque_limit);

    /**
     * @brief Set mechanical zero position
     * @return True if command sent successfully
     */
    bool setZeroPosition();

    /**
     * @brief Set new CAN ID for motor
     * @param new_id New CAN ID
     * @return True if command sent successfully
     */
    bool setCanId(uint8_t new_id);

    /**
     * @brief Save parameters to non-volatile memory
     * @return True if command sent successfully
     */
    bool saveParameters();

    /**
     * @brief Set active reporting mode
     * @param enable Enable (1) or disable (0) active reporting
     * @param interval_ms Reporting interval in ms
     * @return True if command sent successfully
     */
    bool setActiveReporting(bool enable, uint16_t interval_ms = 10);

    /**
     * @brief Set zero flag status
     * @param zero_flag Zero flag (0 = 0-2π, 1 = -π-π)
     * @return True if command sent successfully
     */
    bool setZeroFlag(uint8_t zero_flag);

    /**
     * @brief Read a parameter from the motor
     * @param param_index Parameter index
     * @param value Pointer to store the parameter value
     * @return True if command sent and response received successfully
     */
    bool readParameter(uint16_t param_index, float *value);

    /**
     * @brief Write a parameter to the motor
     * @param param_index Parameter index
     * @param value Parameter value
     * @return True if command sent successfully
     */
    bool writeParameter(uint16_t param_index, float value);

    /**
     * @brief Process received CAN message
     * @param frame CAN frame to process
     * @return True if message was for this motor and was processed
     */
    bool processCANMessage(struct can_frame &frame);

    /**
     * @brief Get last received feedback from motor
     * @return Motor feedback structure
     */
    RS03MotorFeedback getFeedback();

    /**
     * @brief Get detailed fault information
     * @return Motor fault structure
     */
    RS03MotorFault getFault();

    /**
     * @brief Clear motor fault
     * @return True if command sent successfully
     */
    bool clearFault();

    /**
     * @brief Check if motor is in fault state
     * @return True if motor has a fault
     */
    bool hasFault();

    /**
     * @brief Get human-readable description of fault
     * @param fault_code Fault code to describe
     * @return String containing fault description
     */
    String getFaultDescription(uint32_t fault_code);

    /**
     * @brief Test motor position control
     * @param position Target position in radians
     * @return True if test successful
     */
    bool testPositionControl(float position);

    /**
     * @brief Test motor velocity control
     * @param velocity Target velocity in rad/s
     * @param duration_ms Test duration in milliseconds
     * @return True if test successful
     */
    bool testVelocityControl(float velocity, uint32_t duration_ms);

    /**
     * @brief Test motor sinusoidal movement
     * @param amplitude Amplitude in radians
     * @param frequency Frequency in Hz
     * @param duration_ms Test duration in milliseconds
     * @return True if test successful
     */
    bool testSinusoidalMovement(float amplitude, float frequency, uint32_t duration_ms);

private:
    Adafruit_MCP2515 &mcp2515;              // MCP2515 CAN controller instance
    uint8_t motor_id;              // Motor CAN ID
    uint8_t master_id;             // Master device CAN ID
    bool is_enabled;               // Flag to track if motor is enabled
    uint8_t current_mode;          // Current operating mode
    RS03MotorFeedback feedback;    // Last received feedback
    RS03MotorFault fault;          // Current fault status
    unsigned long last_feedback;   // Timestamp of last received feedback
    bool waiting_for_response;     // Flag to indicate waiting for response
    uint16_t last_param_read;      // Last parameter requested
    float param_response;          // Parameter response value

    /**
     * @brief Convert float to uint based on min/max range
     * @param x Value to convert
     * @param x_min Minimum value
     * @param x_max Maximum value
     * @param bits Number of bits
     * @return Converted value
     */
    int floatToUint(float x, float x_min, float x_max, int bits);

    /**
     * @brief Convert uint to float based on min/max range
     * @param x Value to convert
     * @param x_min Minimum value
     * @param x_max Maximum value
     * @param bits Number of bits
     * @return Converted value
     */
    float uintToFloat(int x, float x_min, float x_max, int bits);

    /**
     * @brief Create extended CAN ID
     * @param comm_type Communication type
     * @param dest_id Destination ID
     * @param data2 Data area 2
     * @return Extended CAN ID
     */
    uint32_t createExtendedId(uint8_t comm_type, uint8_t dest_id, uint16_t data2 = 0);

    /**
     * @brief Send a CAN message
     * @param comm_type Communication type
     * @param dest_id Destination ID
     * @param data Pointer to data
     * @param length Data length
     * @param data2 Data area 2
     * @return True if message sent successfully
     */
    bool sendCANMessage(uint8_t comm_type, uint8_t dest_id, uint8_t *data, uint8_t length, uint16_t data2 = 0);

    /**
     * @brief Update fault information based on status
     * @param status Status value from motor
     */
    void updateFaultFromStatus(uint8_t status);

    /**
     * @brief Handle motor feedback message
     * @param frame CAN frame containing feedback
     */
    void handleMotorFeedback(struct can_frame &frame);

    /**
     * @brief Handle parameter response message
     * @param frame CAN frame containing parameter response
     */
    void handleParameterResponse(struct can_frame &frame);

    /**
     * @brief Handle fault feedback message
     * @param frame CAN frame containing fault feedback
     */
    void handleFaultFeedback(struct can_frame &frame);
};

#endif // RS03MOTOR_H 