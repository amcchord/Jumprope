/**
 * @file RS03Motor.cpp
 * @brief Implementation file for RS03 motor control library
 * @author Generated by AI Assistant
 * @date 2023
 */

#include "RS03Motor.h"

// Constructor
RS03Motor::RS03Motor(Adafruit_MCP2515 &mcp2515_instance, uint8_t motor_id, uint8_t master_id)
    : mcp2515(mcp2515_instance), motor_id(motor_id), master_id(master_id), is_enabled(false),
      current_mode(MODE_OPERATION), last_feedback(0), waiting_for_response(false),
      last_param_read(0), param_response(0) {
    // Initialize feedback structure
    memset(&feedback, 0, sizeof(feedback));
    // Initialize fault structure
    memset(&fault, 0, sizeof(fault));
}

// Initialize the motor
bool RS03Motor::begin() {
    // Reset is_enabled flag
    is_enabled = false;
    
    // Set current_mode to MODE_OPERATION
    current_mode = MODE_OPERATION;
    
    // Reset feedback and fault structures
    memset(&feedback, 0, sizeof(feedback));
    memset(&fault, 0, sizeof(fault));
    
    // Disable active reporting by default
    if (!setActiveReporting(false)) {
        return false;
    }
    
    // Read some parameters to verify communication
    float param_value;
    if (!readParameter(PARAM_VBUS, &param_value)) {
        return false;
    }
    
    return true;
}

// Enable the motor
bool RS03Motor::enable() {
    uint8_t data[8] = {0};
    bool result = sendCANMessage(COMM_MOTOR_ENABLE, motor_id, data, 8, master_id << 8);
    
    if (result) {
        is_enabled = true;
    }
    
    return result;
}

// Disable the motor
bool RS03Motor::disable(bool clear_fault) {
    uint8_t data[8] = {0};
    
    if (clear_fault) {
        data[0] = 1;
    }
    
    bool result = sendCANMessage(COMM_MOTOR_STOP, motor_id, data, 8, master_id << 8);
    
    if (result) {
        is_enabled = false;
    }
    
    return result;
}

// Set motor operation mode
bool RS03Motor::setMode(uint8_t mode) {
    if (mode != MODE_OPERATION && 
        mode != MODE_POSITION_PP && 
        mode != MODE_VELOCITY && 
        mode != MODE_CURRENT && 
        mode != MODE_POSITION_CSP) {
        return false;
    }
    
    bool result = writeParameter(PARAM_RUN_MODE, (float)mode);
    
    if (result) {
        current_mode = mode;
    }
    
    return result;
}

// Set position (CSP mode)
bool RS03Motor::setPosition(float position) {
    if (current_mode != MODE_POSITION_CSP) {
        if (!setMode(MODE_POSITION_CSP)) {
            return false;
        }
    }
    
    return writeParameter(PARAM_LOC_REF, position);
}

// Set position with parameters (PP mode)
bool RS03Motor::setPositionWithParams(float position, float velocity, float acceleration) {
    if (current_mode != MODE_POSITION_PP) {
        if (!setMode(MODE_POSITION_PP)) {
            return false;
        }
    }
    
    if (!writeParameter(PARAM_VEL_MAX, velocity)) {
        return false;
    }
    
    if (!writeParameter(PARAM_ACC_SET, acceleration)) {
        return false;
    }
    
    return writeParameter(PARAM_LOC_REF, position);
}

// Set velocity
bool RS03Motor::setVelocity(float velocity) {
    if (current_mode != MODE_VELOCITY) {
        if (!setMode(MODE_VELOCITY)) {
            return false;
        }
    }
    
    return writeParameter(PARAM_SPD_REF, velocity);
}

// Set acceleration for velocity mode
bool RS03Motor::setAcceleration(float acceleration) {
    return writeParameter(PARAM_ACC_RAD, acceleration);
}

// Set current (torque)
bool RS03Motor::setCurrent(float current) {
    if (current_mode != MODE_CURRENT) {
        if (!setMode(MODE_CURRENT)) {
            return false;
        }
    }
    
    return writeParameter(PARAM_IQ_REF, current);
}

// Set operation control parameters
bool RS03Motor::setOperationControl(float position, float velocity, float torque, float kp, float kd) {
    if (current_mode != MODE_OPERATION) {
        if (!setMode(MODE_OPERATION)) {
            return false;
        }
    }
    
    uint8_t data[8] = {0};
    
    // Convert position (radians) to 16-bit value
    uint16_t pos_int = floatToUint(position, P_MIN, P_MAX, 16);
    data[0] = pos_int >> 8;
    data[1] = pos_int & 0xFF;
    
    // Convert velocity (rad/s) to 16-bit value
    uint16_t vel_int = floatToUint(velocity, V_MIN, V_MAX, 16);
    data[2] = vel_int >> 8;
    data[3] = vel_int & 0xFF;
    
    // Convert kp to 16-bit value
    uint16_t kp_int = floatToUint(kp, KP_MIN, KP_MAX, 16);
    data[4] = kp_int >> 8;
    data[5] = kp_int & 0xFF;
    
    // Convert kd to 16-bit value
    uint16_t kd_int = floatToUint(kd, KD_MIN, KD_MAX, 16);
    data[6] = kd_int >> 8;
    data[7] = kd_int & 0xFF;
    
    // Create torque data for the data2 field in extended ID
    uint16_t torque_int = floatToUint(torque, T_MIN, T_MAX, 16);
    
    // Send operation control message
    return sendCANMessage(COMM_OPERATION_CONTROL, motor_id, data, 8, torque_int);
}

// Set torque limit
bool RS03Motor::setTorqueLimit(float torque_limit) {
    return writeParameter(PARAM_LIMIT_TORQUE, torque_limit);
}

// Set mechanical zero position
bool RS03Motor::setZeroPosition() {
    uint8_t data[8] = {0};
    data[0] = 1;
    
    return sendCANMessage(COMM_SET_ZERO, motor_id, data, 8, master_id << 8);
}

// Set new CAN ID for motor
bool RS03Motor::setCanId(uint8_t new_id) {
    uint8_t data[8] = {0};
    
    bool result = sendCANMessage(COMM_SET_CAN_ID, motor_id, data, 8, (new_id << 16) | (master_id << 8));
    
    if (result) {
        motor_id = new_id;
    }
    
    return result;
}

// Save parameters to non-volatile memory
bool RS03Motor::saveParameters() {
    uint8_t data[8] = {0};
    
    return sendCANMessage(COMM_SAVE_PARAMS, motor_id, data, 8, master_id << 8);
}

// Set active reporting mode
bool RS03Motor::setActiveReporting(bool enable, uint16_t interval_ms) {
    uint8_t data[8] = {0};
    
    // Enable or disable active reporting
    data[0] = enable ? 1 : 0;
    
    bool result = sendCANMessage(COMM_ACTIVE_REPORTING, motor_id, data, 8, master_id << 8);
    
    if (result && enable) {
        // Set the reporting interval if enabled
        uint16_t interval_value = (interval_ms / 5) + 1; // 1 corresponds to 10ms
        if (interval_value < 1) interval_value = 1;
        result = writeParameter(PARAM_EPS_CAN_TIME, (float)interval_value);
    }
    
    return result;
}

// Set zero flag status
bool RS03Motor::setZeroFlag(uint8_t zero_flag) {
    return writeParameter(PARAM_ZERO_STA, (float)zero_flag);
}

// Read a parameter from the motor
bool RS03Motor::readParameter(uint16_t param_index, float *value) {
    uint8_t data[8] = {0};
    
    // Set parameter index
    data[0] = param_index & 0xFF;
    data[1] = (param_index >> 8) & 0xFF;
    
    waiting_for_response = true;
    last_param_read = param_index;
    
    if (!sendCANMessage(COMM_READ_PARAM, motor_id, data, 8, master_id << 8)) {
        waiting_for_response = false;
        return false;
    }
    
    // Wait for response with timeout
    unsigned long start_time = millis();
    while (waiting_for_response && (millis() - start_time < 500)) {
        struct can_frame frame;
        if (processCANMessage(frame)) {
            // Message was processed
        }
        delay(1);
    }
    
    if (waiting_for_response) {
        waiting_for_response = false;
        return false;
    }
    
    *value = param_response;
    return true;
}

// Write a parameter to the motor
bool RS03Motor::writeParameter(uint16_t param_index, float value) {
    uint8_t data[8] = {0};
    
    // Set parameter index
    data[0] = param_index & 0xFF;
    data[1] = (param_index >> 8) & 0xFF;
    
    // Set parameter value (4 bytes)
    memcpy(&data[4], &value, 4);
    
    return sendCANMessage(COMM_WRITE_PARAM, motor_id, data, 8, master_id << 8);
}

// Process received CAN message
bool RS03Motor::processCANMessage(struct can_frame &frame) {
    if (mcp2515.parsePacket()) {
        frame.can_id = mcp2515.packetId();
        frame.can_dlc = mcp2515.available();
        for (int i = 0; i < frame.can_dlc && i < 8; i++) {
            frame.data[i] = mcp2515.read();
        }
        return true;
    }
    return false;
}

// Get last received feedback from motor
RS03MotorFeedback RS03Motor::getFeedback() {
    return feedback;
}

// Get detailed fault information
RS03MotorFault RS03Motor::getFault() {
    return fault;
}

// Clear motor fault
bool RS03Motor::clearFault() {
    return disable(true);
}

// Check if motor has a fault
bool RS03Motor::hasFault() {
    return (fault.uncalibrated || 
            fault.overload || 
            fault.encoder_fault || 
            fault.overtemperature || 
            fault.overcurrent || 
            fault.undervoltage);
}

// Get human-readable description of fault
String RS03Motor::getFaultDescription(uint32_t fault_code) {
    String description = "";
    
    if (fault_code & (1 << 0)) {
        description += "Motor overtemperature fault. ";
    }
    
    if (fault_code & (1 << 1)) {
        description += "Driver chip fault. ";
    }
    
    if (fault_code & (1 << 2)) {
        description += "Undervoltage fault. ";
    }
    
    if (fault_code & (1 << 3)) {
        description += "Overvoltage fault. ";
    }
    
    if (fault_code & (1 << 7)) {
        description += "Encoder not calibrated. ";
    }
    
    if (fault_code & (1 << 14)) {
        description += "Gridlock IÂ²T overload fault. ";
    }
    
    if (description.length() == 0) {
        description = "No fault.";
    }
    
    return description;
}

// Test motor position control
bool RS03Motor::testPositionControl(float position) {
    if (!is_enabled) {
        if (!enable()) {
            return false;
        }
    }
    
    if (!setPosition(position)) {
        return false;
    }
    
    // Wait for position to be reached with timeout
    unsigned long start_time = millis();
    float position_error = 1.0; // Initial error value
    
    while (abs(position_error) > 0.05 && (millis() - start_time < 5000)) {
        struct can_frame frame;
        if (processCANMessage(frame)) {
            // Message was processed
        }
        
        position_error = position - feedback.position;
        
        // Check for faults
        if (hasFault()) {
            String fault_desc = getFaultDescription(fault.fault_details);
            Serial.print("Motor fault during position test: ");
            Serial.println(fault_desc);
            return false;
        }
        
        delay(10);
    }
    
    return (abs(position_error) <= 0.05);
}

// Test motor velocity control
bool RS03Motor::testVelocityControl(float velocity, uint32_t duration_ms) {
    if (!is_enabled) {
        if (!enable()) {
            return false;
        }
    }
    
    if (!setVelocity(velocity)) {
        return false;
    }
    
    // Run for specified duration
    unsigned long start_time = millis();
    
    while ((millis() - start_time < duration_ms)) {
        struct can_frame frame;
        if (processCANMessage(frame)) {
            // Message was processed
        }
        
        // Check for faults
        if (hasFault()) {
            String fault_desc = getFaultDescription(fault.fault_details);
            Serial.print("Motor fault during velocity test: ");
            Serial.println(fault_desc);
            return false;
        }
        
        delay(10);
    }
    
    // Stop the motor
    return setVelocity(0.0);
}

// Test motor sinusoidal movement
bool RS03Motor::testSinusoidalMovement(float amplitude, float frequency, uint32_t duration_ms) {
    if (!is_enabled) {
        if (!enable()) {
            return false;
        }
    }
    
    // Must be in position mode for sinusoidal movement
    if (current_mode != MODE_POSITION_CSP) {
        if (!setMode(MODE_POSITION_CSP)) {
            return false;
        }
    }
    
    // Calculate center position (current position)
    float center_position = feedback.position;
    
    // Run sinusoidal movement for specified duration
    unsigned long start_time = millis();
    
    while ((millis() - start_time < duration_ms)) {
        // Calculate sine wave position
        float elapsed_seconds = (millis() - start_time) / 1000.0;
        float angle = 2 * PI * frequency * elapsed_seconds;
        float target_position = center_position + amplitude * sin(angle);
        
        // Set position
        setPosition(target_position);
        
        // Process incoming messages
        struct can_frame frame;
        if (processCANMessage(frame)) {
            // Message was processed
        }
        
        // Check for faults
        if (hasFault()) {
            String fault_desc = getFaultDescription(fault.fault_details);
            Serial.print("Motor fault during sinusoidal test: ");
            Serial.println(fault_desc);
            return false;
        }
        
        delay(10);
    }
    
    // Return to center position
    return setPosition(center_position);
}

// Convert float to uint based on min/max range
int RS03Motor::floatToUint(float x, float x_min, float x_max, int bits) {
    float span = x_max - x_min;
    float offset = x_min;
    
    if (x > x_max) x = x_max;
    else if (x < x_min) x = x_min;
    
    return (int)((x - offset) * ((float)((1 << bits) - 1)) / span);
}

// Convert uint to float based on min/max range
float RS03Motor::uintToFloat(int x, float x_min, float x_max, int bits) {
    float span = x_max - x_min;
    float offset = x_min;
    
    return ((float)x) * span / ((float)((1 << bits) - 1)) + offset;
}

// Create extended CAN ID
uint32_t RS03Motor::createExtendedId(uint8_t comm_type, uint8_t dest_id, uint16_t data2) {
    uint32_t id = 0;
    
    // Communication type (bits 24-28)
    id |= ((uint32_t)comm_type & 0x1F) << 24;
    
    // Data area 2 (bits 8-23)
    id |= ((uint32_t)data2 & 0xFFFF) << 8;
    
    // Destination address (bits 0-7)
    id |= dest_id & 0xFF;
    
    return id;
}

// Send a CAN message
bool RS03Motor::sendCANMessage(uint8_t comm_type, uint8_t dest_id, uint8_t *data, uint8_t length, uint16_t data2) {
    uint32_t extended_id = createExtendedId(comm_type, dest_id, data2);
    
    if (mcp2515.beginPacket(extended_id)) {
        for (int i = 0; i < length; i++) {
            mcp2515.write(data[i]);
        }
        return mcp2515.endPacket();
    }
    return false;
}

// Update fault information based on status
void RS03Motor::updateFaultFromStatus(uint8_t status) {
    fault.uncalibrated = (status >> 5) & 0x01;
    fault.overload = (status >> 4) & 0x01;
    fault.encoder_fault = (status >> 3) & 0x01;
    fault.overtemperature = (status >> 2) & 0x01;
    fault.overcurrent = (status >> 1) & 0x01;
    fault.undervoltage = status & 0x01;
    
    // Update fault string
    if (hasFault()) {
        snprintf(fault.fault_str, sizeof(fault.fault_str), "%s%s%s%s%s%s",
            fault.uncalibrated ? "Not calibrated. " : "",
            fault.overload ? "Overload. " : "",
            fault.encoder_fault ? "Encoder fault. " : "",
            fault.overtemperature ? "Overtemperature. " : "",
            fault.overcurrent ? "Overcurrent. " : "",
            fault.undervoltage ? "Undervoltage. " : "");
    } else {
        strncpy(fault.fault_str, "No fault.", sizeof(fault.fault_str));
    }
}

// Handle motor feedback message
void RS03Motor::handleMotorFeedback(struct can_frame &frame) {
    // Extract motor ID
    uint32_t id = frame.can_id;
    uint8_t motor_id_from_msg = (id >> 16) & 0xFF;
    
    // Check if this feedback is from our motor
    if (motor_id_from_msg != motor_id) {
        return;
    }
    
    // Extract fault status from bits 16-21
    uint8_t fault_status = (id >> 16) & 0x3F;
    updateFaultFromStatus(fault_status);
    
    // Extract mode status from bits 22-23
    feedback.mode = (id >> 22) & 0x03;
    
    // Extract position from first 2 bytes
    uint16_t pos_int = (frame.data[0] << 8) | frame.data[1];
    feedback.position = uintToFloat(pos_int, P_MIN, P_MAX, 16);
    
    // Extract velocity from next 2 bytes
    uint16_t vel_int = (frame.data[2] << 8) | frame.data[3];
    feedback.velocity = uintToFloat(vel_int, V_MIN, V_MAX, 16);
    
    // Extract torque from next 2 bytes
    uint16_t torque_int = (frame.data[4] << 8) | frame.data[5];
    feedback.torque = uintToFloat(torque_int, T_MIN, T_MAX, 16);
    
    // Extract temperature from last 2 bytes
    uint16_t temp_int = (frame.data[6] << 8) | frame.data[7];
    feedback.temperature = temp_int / 10.0;
    
    // Update timestamp
    last_feedback = millis();
}

// Handle parameter response message
void RS03Motor::handleParameterResponse(struct can_frame &frame) {
    // Extract parameter index from first 2 bytes
    uint16_t param_index = (frame.data[0]) | (frame.data[1] << 8);
    
    // Check if this is the parameter we requested
    if (param_index == last_param_read) {
        // Extract parameter value from last 4 bytes
        memcpy(&param_response, &frame.data[4], 4);
        
        // Reset waiting flag
        waiting_for_response = false;
    }
}

// Handle fault feedback message
void RS03Motor::handleFaultFeedback(struct can_frame &frame) {
    // Extract fault value from first 4 bytes
    memcpy(&fault.fault_details, &frame.data[0], 4);
    
    // Update individual fault flags
    fault.uncalibrated = (fault.fault_details >> 7) & 0x01;
    fault.overload = (fault.fault_details >> 14) & 0x01;
    fault.encoder_fault = 0; // Not directly in the fault bits, infer from other faults
    fault.overtemperature = (fault.fault_details >> 0) & 0x01;
    fault.overcurrent = 0; // Not directly in the fault bits, infer from other faults
    fault.undervoltage = (fault.fault_details >> 2) & 0x01;
    
    // Update fault string with detailed description
    strncpy(fault.fault_str, getFaultDescription(fault.fault_details).c_str(), sizeof(fault.fault_str));
} 