/**
 * @file RS03MultiMotor.ino
 * @brief Example sketch for controlling multiple RS03 motors
 * @author Generated by AI Assistant
 * @date 2023
 */

#include <Arduino.h>
#include <SPI.h>
#include <mcp2515.h>
#include <RS03Motor.h>

// CAN module pins
#define CAN_CS_PIN 5
#define CAN_INT_PIN 4

// Baudrate for CAN bus (1Mbps for RS03 motors)
#define CAN_SPEED CAN_1000KBPS
#define CAN_CRYSTAL MCP_8MHZ

// Master ID
#define MASTER_ID 0

// Number of motors
#define NUM_MOTORS 3

// Create MCP2515 instance
MCP2515 mcp2515(CAN_CS_PIN);

// Create RS03Motor instances
RS03Motor motors[NUM_MOTORS] = {
  RS03Motor(mcp2515, 1, MASTER_ID),
  RS03Motor(mcp2515, 2, MASTER_ID),
  RS03Motor(mcp2515, 3, MASTER_ID)
};

// Motor patterns
enum MotorPattern {
  PATTERN_STOP,
  PATTERN_SEQUENCE,
  PATTERN_WAVE,
  PATTERN_SYNCHRONIZED
};

MotorPattern currentPattern = PATTERN_STOP;
unsigned long patternStartTime = 0;
unsigned long lastStatusTime = 0;

void setup() {
  // Initialize serial for debugging
  Serial.begin(115200);
  Serial.println("RS03 Multi-Motor Control");
  
  // Initialize SPI for CAN communication
  SPI.begin();
  
  // Initialize CAN controller
  if (initCAN()) {
    Serial.println("CAN initialized successfully");
  } else {
    Serial.println("CAN initialization failed");
    while (1); // Halt on error
  }
  
  // Setup interrupt pin for received messages
  pinMode(CAN_INT_PIN, INPUT_PULLUP);
  
  // Initialize motors
  Serial.println("Initializing motors...");
  for (int i = 0; i < NUM_MOTORS; i++) {
    if (motors[i].begin()) {
      Serial.print("Motor ");
      Serial.print(i + 1);
      Serial.println(" initialized successfully");
    } else {
      Serial.print("Motor ");
      Serial.print(i + 1);
      Serial.println(" initialization failed");
      while (1); // Halt on error
    }
  }
  
  // Wait a bit before starting
  delay(1000);
  
  // Set all motors to position mode
  for (int i = 0; i < NUM_MOTORS; i++) {
    motors[i].setMode(MODE_POSITION_CSP);
  }
  
  // Enable all motors
  for (int i = 0; i < NUM_MOTORS; i++) {
    motors[i].enable();
  }
  
  // Start with pattern 1
  currentPattern = PATTERN_SEQUENCE;
  patternStartTime = millis();
  Serial.println("Starting sequence pattern");
}

void loop() {
  // Process incoming CAN messages
  if (digitalRead(CAN_INT_PIN) == LOW) {
    struct can_frame frame;
    if (mcp2515.readMessage(&frame) == MCP2515::ERROR_OK) {
      for (int i = 0; i < NUM_MOTORS; i++) {
        motors[i].processCANMessage(frame);
      }
    }
  }
  
  // Check for user input to change pattern
  if (Serial.available()) {
    char input = Serial.read();
    switch (input) {
      case '0':
        Serial.println("Stopping all motors");
        currentPattern = PATTERN_STOP;
        patternStartTime = millis();
        break;
      case '1':
        Serial.println("Starting sequence pattern");
        currentPattern = PATTERN_SEQUENCE;
        patternStartTime = millis();
        break;
      case '2':
        Serial.println("Starting wave pattern");
        currentPattern = PATTERN_WAVE;
        patternStartTime = millis();
        break;
      case '3':
        Serial.println("Starting synchronized pattern");
        currentPattern = PATTERN_SYNCHRONIZED;
        patternStartTime = millis();
        break;
    }
  }
  
  // Run the selected pattern
  runPattern(currentPattern);
  
  // Print motor status periodically
  if (millis() - lastStatusTime > 2000) {
    printMotorStatus();
    lastStatusTime = millis();
  }
}

// Run the selected motor pattern
void runPattern(MotorPattern pattern) {
  float positions[NUM_MOTORS] = {0};
  
  switch (pattern) {
    case PATTERN_STOP:
      // Stop all motors
      for (int i = 0; i < NUM_MOTORS; i++) {
        motors[i].setVelocity(0);
      }
      break;
      
    case PATTERN_SEQUENCE:
      // Sequence pattern: motors move one after another
      {
        unsigned long elapsed = millis() - patternStartTime;
        uint8_t active_motor = (elapsed / 2000) % NUM_MOTORS;
        
        for (int i = 0; i < NUM_MOTORS; i++) {
          if (i == active_motor) {
            float angle = sin((elapsed % 2000) / 2000.0 * 2 * PI);
            motors[i].setPosition(angle);
          } else {
            motors[i].setPosition(0);
          }
        }
      }
      break;
      
    case PATTERN_WAVE:
      // Wave pattern: motors move in a wave
      {
        unsigned long elapsed = millis() - patternStartTime;
        
        for (int i = 0; i < NUM_MOTORS; i++) {
          float phase = 2 * PI * i / NUM_MOTORS;
          float angle = sin((elapsed / 1000.0) + phase);
          motors[i].setPosition(angle);
        }
      }
      break;
      
    case PATTERN_SYNCHRONIZED:
      // Synchronized pattern: all motors move together
      {
        unsigned long elapsed = millis() - patternStartTime;
        float angle = sin(elapsed / 1000.0);
        
        for (int i = 0; i < NUM_MOTORS; i++) {
          motors[i].setPosition(angle);
        }
      }
      break;
  }
}

// Print status of all motors
void printMotorStatus() {
  Serial.println("\nMotor Status:");
  
  for (int i = 0; i < NUM_MOTORS; i++) {
    RS03MotorFeedback feedback = motors[i].getFeedback();
    
    Serial.print("Motor ");
    Serial.print(i + 1);
    Serial.print(" - Pos: ");
    Serial.print(feedback.position);
    Serial.print(" rad, Vel: ");
    Serial.print(feedback.velocity);
    Serial.print(" rad/s, Temp: ");
    Serial.print(feedback.temperature);
    Serial.println(" Â°C");
    
    if (motors[i].hasFault()) {
      RS03MotorFault fault = motors[i].getFault();
      Serial.print("  Fault: ");
      Serial.println(fault.fault_str);
    }
  }
}

// Function to initialize CAN controller
bool initCAN() {
  mcp2515.reset();
  MCP2515::ERROR result = mcp2515.setBitrate(CAN_SPEED, CAN_CRYSTAL);
  
  if (result == MCP2515::ERROR_OK) {
    mcp2515.setNormalMode();
    return true;
  }
  
  return false;
} 