/**
 * @file RS03Motor_Test.ino
 * @brief Example sketch for testing RS03 motor control
 * @author Generated by AI Assistant
 * @date 2023
 */

#include <Arduino.h>
#include <SPI.h>
#include <mcp2515.h>
#include <RS03Motor.h>

// CAN module pins
#define CAN_CS_PIN 5
#define CAN_INT_PIN 4

// Baudrate for CAN bus (1Mbps for RS03 motors)
#define CAN_SPEED CAN_1000KBPS
#define CAN_CRYSTAL MCP_8MHZ

// Motor IDs
#define MOTOR_ID 1
#define MASTER_ID 0

// Create MCP2515 instance
MCP2515 mcp2515(CAN_CS_PIN);

// Create RS03Motor instance
RS03Motor motor(mcp2515, MOTOR_ID, MASTER_ID);

// Test state machine
enum TestState {
  TEST_INIT,
  TEST_POSITION,
  TEST_VELOCITY,
  TEST_SINUSOIDAL,
  TEST_DONE
};

TestState currentState = TEST_INIT;
unsigned long stateStartTime = 0;
bool testSuccess = false;

void setup() {
  // Initialize serial for debugging
  Serial.begin(115200);
  Serial.println("RS03 Motor Test");
  
  // Initialize SPI for CAN communication
  SPI.begin();
  
  // Initialize CAN controller
  if (initCAN()) {
    Serial.println("CAN initialized successfully");
  } else {
    Serial.println("CAN initialization failed");
    while (1); // Halt on error
  }
  
  // Setup interrupt pin for received messages
  pinMode(CAN_INT_PIN, INPUT_PULLUP);
  
  // Initialize the motor
  Serial.println("Initializing motor...");
  if (motor.begin()) {
    Serial.println("Motor initialized successfully");
  } else {
    Serial.println("Motor initialization failed");
    while (1); // Halt on error
  }
  
  // Start the state machine
  stateStartTime = millis();
}

void loop() {
  // Process incoming CAN messages
  if (digitalRead(CAN_INT_PIN) == LOW) {
    struct can_frame frame;
    if (mcp2515.readMessage(&frame) == MCP2515::ERROR_OK) {
      motor.processCANMessage(frame);
    }
  }
  
  // State machine for testing
  switch (currentState) {
    case TEST_INIT:
      if (millis() - stateStartTime > 1000) {
        Serial.println("Starting position control test...");
        currentState = TEST_POSITION;
        stateStartTime = millis();
      }
      break;
      
    case TEST_POSITION:
      if (millis() - stateStartTime < 100) {
        // Enable the motor
        motor.enable();
      } else if (millis() - stateStartTime < 5000) {
        // Test position control
        static bool test_started = false;
        if (!test_started) {
          testSuccess = motor.testPositionControl(1.0); // Move to 1 radian
          test_started = true;
        }
      } else {
        // Test complete, move to next test
        if (testSuccess) {
          Serial.println("Position control test succeeded");
        } else {
          Serial.println("Position control test failed");
        }
        
        Serial.println("Starting velocity control test...");
        currentState = TEST_VELOCITY;
        stateStartTime = millis();
      }
      break;
      
    case TEST_VELOCITY:
      if (millis() - stateStartTime < 100) {
        // Ensure the motor is enabled
        motor.enable();
      } else if (millis() - stateStartTime < 5000) {
        // Test velocity control
        static bool test_started = false;
        if (!test_started) {
          testSuccess = motor.testVelocityControl(1.0, 3000); // Rotate at 1 rad/s for 3 seconds
          test_started = true;
        }
      } else {
        // Test complete, move to next test
        if (testSuccess) {
          Serial.println("Velocity control test succeeded");
        } else {
          Serial.println("Velocity control test failed");
        }
        
        Serial.println("Starting sinusoidal movement test...");
        currentState = TEST_SINUSOIDAL;
        stateStartTime = millis();
      }
      break;
      
    case TEST_SINUSOIDAL:
      if (millis() - stateStartTime < 100) {
        // Ensure the motor is enabled
        motor.enable();
      } else if (millis() - stateStartTime < 10000) {
        // Test sinusoidal movement
        static bool test_started = false;
        if (!test_started) {
          testSuccess = motor.testSinusoidalMovement(0.5, 0.5, 8000); // 0.5 rad amplitude, 0.5 Hz for 8 seconds
          test_started = true;
        }
      } else {
        // Test complete, move to done state
        if (testSuccess) {
          Serial.println("Sinusoidal movement test succeeded");
        } else {
          Serial.println("Sinusoidal movement test failed");
        }
        
        // Disable the motor
        motor.disable();
        
        Serial.println("All tests completed");
        currentState = TEST_DONE;
      }
      break;
      
    case TEST_DONE:
      // All tests completed, just monitor motor status
      if (millis() - stateStartTime > 1000) {
        // Print motor feedback every second
        RS03MotorFeedback feedback = motor.getFeedback();
        
        Serial.println("\nMotor Status:");
        Serial.print("Position: "); Serial.print(feedback.position); Serial.println(" rad");
        Serial.print("Velocity: "); Serial.print(feedback.velocity); Serial.println(" rad/s");
        Serial.print("Torque: "); Serial.print(feedback.torque); Serial.println(" Nm");
        Serial.print("Temperature: "); Serial.print(feedback.temperature); Serial.println(" Â°C");
        
        if (motor.hasFault()) {
          RS03MotorFault fault = motor.getFault();
          Serial.print("Fault: "); Serial.println(fault.fault_str);
        }
        
        stateStartTime = millis();
      }
      break;
  }
}

// Function to initialize CAN controller
bool initCAN() {
  mcp2515.reset();
  MCP2515::ERROR result = mcp2515.setBitrate(CAN_SPEED, CAN_CRYSTAL);
  
  if (result == MCP2515::ERROR_OK) {
    mcp2515.setNormalMode();
    return true;
  }
  
  return false;
} 